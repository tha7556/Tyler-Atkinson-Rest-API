<h2>Traveling Salesman</h2>
<h3>Background</h3>
<p>The Traveling Salesman problem is a common optimization excercise in computer science. 
  It begins with x cities and the goal is to find the shortest round trip that visits each city exactly once.
  It is an interesting problem because it seems so simple, and yet as the number of cities increases the difficulty increases exponentially.
  With x cities, there are (x-1)! potential routes. It's x-1 since the route is a circle, the starting city can be left the same. 
  For example 14 cities would have 6,227,020,800 potential routes, 15 cities would have 87,178,291,200 potential routes. 
  That is 80,951,270,400 more routes just from adding one city.
  Because of how complex it can become, there is not a realistic way of checking if a route is truly the shortest route.
  Methods for solving it are usually only approximations.
</p>
<h4>Genetic Algorithm</h4>
<p>A Genetic Algorithm is one of the ways used to solve traveling salesman. 
  It simulates evolution and represents each city as a gene.
  Routes with shorter distances are more likely to pass on their genetic code to future generations.
</p>
<h5><b>Initialization</b></h5>
<p>There are two important variables when setting up a genetic algorithm: mutation rate and population size.
  The mutation rate controls how often mutation is introduced to new generations, while the population size is the total number of routes in each generation.
  If either are too low then there won't be enough diversity to breed new routes.
  However if the mutation rate is too high, then the children will be too different from the parents and it would almost just be random.
  If the population size is too large, it would likely find the best route in fewer generations but would take much longer. 
  This one is set at a population size of 200 and mutation rate of 0.01.
  To begin, the genetic algorithm randomly generates routes equal to the population size.
</p>
<h5><b>Running</b></h5>
<p>After the initialization is completed, the evolution process begins.
  For each route in the population, two parents are selected randomly based on their fitness.
  Fitness in this instance is determined as 1/distance, so routes with high fitness have short routes.
  To create children from those parents, the two are randomly spliced together, ensuring that each city is still only on the route once.
  Once the child is created, each of its genes have a random chance of switching places with another gene based on the mutation rate.
  To ensure best results, the best route is cloned into the next population so that the route is not lost.
  This process is repeated until the best route converges and does not improve after a certain number of generations.
</p>
<h4>Simulated Annealing</h4>
<p>Simulated Annealing is another way used to solve traveling salesman. 
  It simulates the annealing process used in metallurgy to slowly forge the shortest route.
</p>
<h5><b>Annealing In Metallurgy</b></h5>
<p>Annealing is a process to soften a metal to make it easier to work with and to prevent cracking. 
  It involves heating the metal to extreme temperatures above the recrystallization temperature.
  The metal is left at that temperature for a suitable amount of time and then slowly cooled to prepare it for molding.
  This slow cooling is where this algorithm takes its inspiration from.
</p>
<h5><b>Algorithm</b></h5>
<p>Simulated Annealing begins with a high temperature, meaning that the algorithm is much more likely to accept a lesser quality route.
  This likeliness of the algorithm to accept a lesser quality route is called the acceptance probability.
  It will always accept a route better than the current route but only has a chance of accepting lesser routes based on the temperature and the quality of the route.
  Routes are generated by randomly swapping two cities in the route and then checking if it should be accepted.
</p>
<h4>Source</h4>
<p>Here is the original source code for this project: <a href="https://github.com/tha7556/Traveling-Salesman-Problem">[source]</a>.</p>
<p>And here is the source code running the algorithms below: <a href="https://github.com/tha7556/Tyler-Atkinson-Rest-API/tree/master/src/main/java/com/projects/tsp">[source]</a></p>
<h3>Usage</h3>
<p>Move the cities how you want, click the add button to add up to 26 cities or remove button to remove them. 
  There is a minimum of 4 cities because any lower and the results don't really mean anything as there is only 1 or 2 routes.
  Once you have it how you like, click either Run Genetic or Run Simulated Annealing and see the results.
  <br/><b>Reminder: The result is only an estimation of the shortest route. Especially with more cities, the results are not guaranteed to be the shortest.</b>
</p>
<div class="container myContainer">  
  <button (click)="genetic()">Run Genetic</button>
  <button (click)="annealing()">Run Simulated Annealing</button><br/>
  <button (click)="removeCity()">Remove City</button>
  <button (click)="addCity()">Add City</button><br/>
  <svg #svg width="100%" height="410" class="box" (mousemove)="mouseMove($event)" (touchmove)="mouseMove($event)" (mouseup)="mouseUp()" (mouseleave)="mouseUp()" (touchend)="mouseUp()" (touchcancel)="mouseUp()">
    <g *ngFor="let line of lines">
      <line [attr.x1]="line.x1" [attr.y1]="line.y1" [attr.x2]="line.x2" [attr.y2]="line.y2" class="line"/>
    </g>
    <g *ngFor="let city of cities">
      <circle [attr.cx]="city.x" [attr.cy]="city.y" r="20" class="city"/>
      <text class="cityText" (mousedown)="mouseDown($event, city)" (touchstart)="mouseDown($event, city)" [attr.x]="city.x-12" [attr.y]="city.y+11">{{city.name}}</text>
    </g>
  </svg>
  <div *ngIf="running" class="spinnerContainer">
    <mat-spinner class="spinner" style="margin-top: 20%"></mat-spinner>
  </div>
</div>
